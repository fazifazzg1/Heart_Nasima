<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>3D Rotating Heart Style</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Consolas', 'Courier New', monospace;
        }
        canvas {
            display: block;
        }
        /* Стиль из фото для справки и возможного использования */
        .love_word {
            color: #ea80b0;
            text-shadow: 0 0 10px #fff;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 22px;
            transform: rotate(-30deg);
        }
    </style>
</head>
<body>

<canvas id="heartCanvas"></canvas>

<script>
    const canvas = document.getElementById('heartCanvas');
    const ctx = canvas.getContext('2d');

    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    // Данные из фото:
    // Текст: "Nasima" (видно на картинке)
    const text = "Nasima"; 
    const text2 = "I love you";
    
    // Цвет: #ea80b0 (из CSS .love_word)
    const color = "#ea80b0";
    
    // Свечение: 0 0 10px #fff (из CSS text-shadow)
    const shadowColor = "#fff";
    const shadowBlur = 10;
    
    // Шрифт: 1.4rem ~ 22px (из CSS font-size)
    // Пишем чуть меньше, чтобы влезло в canvas 3D сцену красиво, или масштабируем сцену
    const fontSize = 16; 
    
    // Наклон: -30deg (из CSS transform: rotateZ(-30deg))
    // Для анимации "бегущей строки" обычно текст ориентирован по линии или горизонтально.
    // Если нужно вернуть -30, раскомментируйте.
    const textRotation = -30 * Math.PI / 180;

    // Немного уменьшим масштаб сцены, так как шрифт стал крупнее
    const scale = 14; 
    
    // Глобальный сдвиг для анимации текста
    let textOffset = 0;
    const speed = 0.002; // Еще медленнее (было 0.005)

    // Функция для получения точки на сердце
    function getHeartPoint(t) {
        let x = 16 * Math.pow(Math.sin(t), 3);
        let y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
        return {x, y};
    }

    // Устанавливаем фиксированный угол поворота для вида сбоку (как на фото)
    let angleY = 0.6; // Примерно 35 градусов
    const angleX = 0.1; // Небольшой наклон, чтобы лучше читалась форма 

    function render() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);

        const cx = width / 2;
        const cy = height / 2;

        // Обновляем позицию текста (бегущая строка)
        textOffset -= speed;

        // Добавляем пульсацию (биение сердца)
        const time = Date.now() / 1000;
        // Формула для плавного биения: sin(t * speed)
        // scale = 14 + Math.sin(time * 3) * 0.5; 
        // Или более сложная, похожая на сердце:
        const beat = Math.sin(time * 5) * 0.5 + Math.sin(time * 10) * 0.2;
        const currentScale = scale + beat;

        // Настраиваем стили текста
        ctx.font = `${fontSize}px "Consolas", "Courier New", monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Применяем свечение
        ctx.shadowColor = shadowColor;
        ctx.shadowBlur = shadowBlur;
        
        // Letter spacing (поддержка в современных браузерах)
        if (ctx.letterSpacing !== undefined) {
            ctx.letterSpacing = "2px";
        }

        let projected = [];

        // Генерируем точки динамически каждый кадр для эффекта движения
        // Оставляем только ДВА слоя (как две строчки)
        const layers = [
            { z: -1.5, text: text },      // Левая линия (Nasima)
            { z: 1.5, text: text2 }       // Правая линия (I love you)
        ];

        layers.forEach(layer => {
            for (let t = 0; t < Math.PI * 2; t += 0.1) {
                // Смещаем t на textOffset, чтобы создать эффект движения вдоль кривой
                let currentT = t + textOffset;
                
                let {x, y} = getHeartPoint(currentT);
                
                // 3D вращение (статичное angleY)
                // Используем layer.z вместо z цикла
                let rx = x * Math.cos(angleY) - (layer.z * 2.5) * Math.sin(angleY);
                let rz = x * Math.sin(angleY) + (layer.z * 2.5) * Math.cos(angleY);
                let ry = y;

                let finalY = ry * Math.cos(angleX) - rz * Math.sin(angleX);
                let finalZ = ry * Math.sin(angleX) + rz * Math.cos(angleX);

                let perspective = 600 / (600 + finalZ * currentScale);
                let px = cx + rx * currentScale * perspective;
                let py = cy + finalY * currentScale * perspective;

                projected.push({
                    px: px,
                    py: py,
                    depth: finalZ,
                    perspective: perspective,
                    text: layer.text // Передаем текст для отрисовки
                });
            }
        });

        projected.sort((a, b) => b.depth - a.depth);

        for (let i = 0; i < projected.length; i++) {
            let p = projected[i];
            
            let alpha = Math.max(0.1, Math.min(1, p.perspective));
            
            // Преобразуем hex #ea80b0 в rgba для прозрачности
            // #ea80b0 -> r=234, g=128, b=176
            ctx.fillStyle = `rgba(234, 128, 176, ${alpha})`;
            
            // Отрисовка текста (две строки)
            // Если нужно вращать текст вместе с кривизной, здесь можно добавить rotate
            ctx.save();
            ctx.translate(p.px, p.py);
            if (textRotation !== 0) ctx.rotate(textRotation);
            
            // Рисуем текст, соответствующий слою
            ctx.fillText(p.text, 0, 0);
            
            ctx.restore();
        }

        requestAnimationFrame(render);
    }

    render();

    window.addEventListener('resize', () => {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    });
</script>

</body>
</html>
